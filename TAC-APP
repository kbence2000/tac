// app.js
// Egy â€mini Base44â€ backend: GitHub + ChatGPT egy appban
// IndÃ­tÃ¡s: node app.js
// ElÅ‘tte: npm install express axios dotenv openai

import express from "express";
import axios from "axios";
import dotenv from "dotenv";
import OpenAI from "openai";

dotenv.config();

const app = express();
app.use(express.json({ limit: "10mb" }));

const PORT = process.env.PORT || 3000;
const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;

if (!GITHUB_TOKEN || !OPENAI_API_KEY) {
  console.error("âŒ GITHUB_TOKEN vagy OPENAI_API_KEY hiÃ¡nyzik a .env-bÅ‘l!");
  process.exit(1);
}

// OpenAI kliens (ChatGPT)
const openai = new OpenAI({
  apiKey: OPENAI_API_KEY,
});

// GitHub API kliens (alap axios wrapper)
const github = axios.create({
  baseURL: "https://api.github.com",
  headers: {
    Authorization: `Bearer ${GITHUB_TOKEN}`,
    "User-Agent": "tac-dev-hub",
    Accept: "application/vnd.github+json",
  },
});

/**
 * Helper: Repo tree beolvasÃ¡sa (max depth 2, hogy ne legyen brutÃ¡l nagy)
 */
async function getRepoTree(owner, repo, branch = "main") {
  // 1) branch SHA
  const refRes = await github.get(`/repos/${owner}/${repo}/git/refs/heads/${branch}`);
  const commitSha = refRes.data.object.sha;

  // 2) tree lekÃ©rÃ©s
  const treeRes = await github.get(
    `/repos/${owner}/${repo}/git/trees/${commitSha}?recursive=1`
  );

  return treeRes.data.tree; // [{path, type, sha, ...}]
}

/**
 * Helper: fÃ¡jl tartalom lekÃ©rÃ©se
 */
async function getFileContent(owner, repo, path, branch = "main") {
  const res = await github.get(`/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}`, {
    params: { ref: branch },
  });

  if (res.data.encoding === "base64") {
    const buff = Buffer.from(res.data.content, "base64");
    return buff.toString("utf8");
  }
  return res.data.content;
}

/**
 * 1) Repo fÃ¡jlok listÃ¡zÃ¡sa â€“ workflow debug alap
 * POST /api/github/list-files
 * body: { owner, repo, branch? }
 */
app.post("/api/github/list-files", async (req, res) => {
  try {
    const { owner, repo, branch = "main" } = req.body;

    if (!owner || !repo) {
      return res.status(400).json({ error: "owner Ã©s repo kÃ¶telezÅ‘" });
    }

    const tree = await getRepoTree(owner, repo, branch);

    // csak fÃ¡jlok, max 100 elem, hogy ne haljunk meg
    const files = tree
      .filter((t) => t.type === "blob")
      .map((f) => f.path)
      .slice(0, 100);

    res.json({ files, count: files.length });
  } catch (err) {
    console.error("list-files error:", err.response?.data || err.message);
    res.status(500).json({ error: "Nem sikerÃ¼lt listÃ¡zni a fÃ¡jlokat." });
  }
});

/**
 * 2) KonkrÃ©t fÃ¡jl tartalom lekÃ©rÃ©se
 * POST /api/github/get-file
 * body: { owner, repo, path, branch? }
 */
app.post("/api/github/get-file", async (req, res) => {
  try {
    const { owner, repo, path, branch = "main" } = req.body;
    if (!owner || !repo || !path) {
      return res.status(400).json({ error: "owner, repo, path kÃ¶telezÅ‘" });
    }

    const content = await getFileContent(owner, repo, path, branch);
    res.json({ path, content });
  } catch (err) {
    console.error("get-file error:", err.response?.data || err.message);
    res.status(500).json({ error: "Nem sikerÃ¼lt beolvasni a fÃ¡jlt." });
  }
});

/**
 * 3) Debug endpoint â€“ error log + repo -> ChatGPT magyarÃ¡zat + fix Ã¶tlet
 * POST /api/debug/error
 * body: { owner, repo, branch?, errorLog, focusPaths? }
 *
 * focusPaths: opcionÃ¡lis listÃ¡ja a fÃ¡jloknak, amiket Ã©rdemes belerakni a promptba
 */
app.post("/api/debug/error", async (req, res) => {
  try {
    const { owner, repo, branch = "main", errorLog, focusPaths = [] } = req.body;

    if (!owner || !repo || !errorLog) {
      return res.status(400).json({
        error: "owner, repo Ã©s errorLog kÃ¶telezÅ‘ a debug endpointhez.",
      });
    }

    // Ha van megadott fÃ¡jllista, beolvassuk Å‘ket Ã©s bepakoljuk a promptba
    let filesSnippet = "";
    for (const p of focusPaths.slice(0, 5)) {
      try {
        const content = await getFileContent(owner, repo, p, branch);
        // limitÃ¡ljuk a fÃ¡jl mÃ©retet
        const short = content.length > 5000 ? content.slice(0, 5000) + "\n// ...cut..." : content;
        filesSnippet += `\n\n===== FILE: ${p} =====\n${short}`;
      } catch (e) {
        filesSnippet += `\n\n===== FILE: ${p} =====\n// Nem sikerÃ¼lt beolvasni ezt a fÃ¡jlt.`;
      }
    }

    const systemPrompt = `
Te egy senior DevOps + backend fejlesztÅ‘ vagy, aki GitHub workflow hibÃ¡kat elemez.
MagyarÃ¡zd el a hibÃ¡t, majd adj konkrÃ©t lÃ©pÃ©seket Ã©s kÃ³d/jobb konfigurÃ¡ciÃ³s javaslatot.
Ha lehet, adj diff-szerÅ± patch-et is (git diff formÃ¡tum).
`   .trim();

    const userPrompt = `
Ez egy GitHub repo (owner: ${owner}, repo: ${repo}, branch: ${branch}).
Itt az error log (build/test/workflow hibÃ¡bÃ³l):

----- ERROR LOG START -----
${errorLog}
----- ERROR LOG END -----

Ezek a relevÃ¡ns forrÃ¡sfÃ¡jlok rÃ©szletei:
${filesSnippet}

KÃ©rlek:
1. MagyarÃ¡zd el, mi lehet a hiba oka.
2. Ãrd le, mit kell javÃ­tani (lÃ©pÃ©srÅ‘l lÃ©pÃ©sre).
3. Adj konkrÃ©t kÃ³d- vagy config mÃ³dosÃ­tÃ¡s javaslatot.
4. Ha lehet, kÃ©szÃ­ts git diff patch-et is.
`.trim();

    const completion = await openai.responses.create({
      model: "gpt-4.1-mini",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: userPrompt },
      ],
      max_output_tokens: 1000,
    });

    const aiText =
      completion.output[0].content
        .map((chunk) => ("text" in chunk ? chunk.text : ""))
        .join("\n") || "Nincs vÃ¡lasz.";

    res.json({
      explanation: aiText,
    });
  } catch (err) {
    console.error("debug/error endpoint error:", err.response?.data || err.message);
    res.status(500).json({
      error: "Nem sikerÃ¼lt a debug elemzÃ©s ChatGPT-vel.",
    });
  }
});

/**
 * 4) FÃ¡jl refaktor / fix ChatGPT-vel
 * POST /api/refactor/file
 * body: { owner, repo, path, branch?, instructions }
 */
app.post("/api/refactor/file", async (req, res) => {
  try {
    const { owner, repo, path, branch = "main", instructions } = req.body;

    if (!owner || !repo || !path || !instructions) {
      return res.status(400).json({
        error: "owner, repo, path, instructions kÃ¶telezÅ‘.",
      });
    }

    const originalContent = await getFileContent(owner, repo, path, branch);

    const systemPrompt = `
Te egy senior fullstack fejlesztÅ‘ vagy.
Egy meglÃ©vÅ‘ fÃ¡jlt fogsz mÃ³dosÃ­tani a megadott utasÃ­tÃ¡sok alapjÃ¡n.
Fontos: tartsd meg a projekt stÃ­lusÃ¡t, ne tÃ¶rj Ã¶ssze semmit.
VisszatÃ©rÃ©s: CSAK a mÃ³dosÃ­tott teljes fÃ¡jl tartalma, extra kommentÃ¡r nÃ©lkÃ¼l.
`.trim();

    const userPrompt = `
UtasÃ­tÃ¡sok a mÃ³dosÃ­tÃ¡shoz:
${instructions}

Eredeti fÃ¡jl (${path}) tartalma:
-------------------------------
${originalContent}
-------------------------------

KÃ©rlek, add vissza a teljes mÃ³dosÃ­tott fÃ¡jl tartalmÃ¡t.
`.trim();

    const completion = await openai.responses.create({
      model: "gpt-4.1",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: userPrompt },
      ],
      max_output_tokens: 2000,
    });

    const newFileContent =
      completion.output[0].content
        .map((chunk) => ("text" in chunk ? chunk.text : ""))
        .join("\n") || "";

    res.json({
      path,
      originalContent,
      newFileContent,
      note: "Ezt a newFileContent-et te tudod commitolni/pusholni GitHubra (kÃ¼lÃ¶n script vagy manuÃ¡lisan).",
    });
  } catch (err) {
    console.error("refactor/file endpoint error:", err.response?.data || err.message);
    res.status(500).json({
      error: "Nem sikerÃ¼lt a fÃ¡jl refaktor ChatGPT-vel.",
    });
  }
});

/**
 * Health check â€“ mint egy mini Base44 â€statusâ€
 */
app.get("/health", (req, res) => {
  res.json({ status: "ok", github: !!GITHUB_TOKEN, openai: !!OPENAI_API_KEY });
});

app.listen(PORT, () => {
  console.log(`ğŸš€ Mini Base44-szerÅ± backend fut: http://localhost:${PORT}`);
});
